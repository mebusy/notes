...menustart

- [Head First Design Patterns](#ceb4d27597053532d28b90d23519ea82)
- [Head First 学习原则](#5e8c168218e62b9925b996275d1c4e29)
- [1 设计模式入门](#5616caa0254d9d34b75045c12685203e)
- [策略模式](#7f10b11f53861282996d481d333af15f)
- [观察者模式](#ed69b1ebfd1c60c731c99be83683c89a)
- [装饰者模式](#815e385363f17f4a5efd3aadecc64271)
- [工厂模式](#b98e9d7c0cb2b3d179c16457b10e53b4)
- [单件模式](#c8ef5b6fbf8c995ba753dbf56c4f4981)
- [命令模式](#a5c7aeffdabd7096cc1366f19600fa62)

...menuend


<h2 id="ceb4d27597053532d28b90d23519ea82"></h2>


# Head First Design Patterns 

- all codes
    - https://github.com/bethrobson/Head-First-Design-Patterns

<h2 id="5e8c168218e62b9925b996275d1c4e29"></h2>


# Head First 学习原则

 1. 看得到
    - 通过图片， 学习效率更高
 2. 采用一种针对个人的交谈式样风格
    - 讲故事，用通俗的语言
 3. 让学习的人想的更深
    - 除非你很积极的让神经元活动起来，否则你的头脑里什么也不会发生
    - 必须引起读者的好奇，促进，要求并鼓励 读者去解决问题，得出结论，产生新的知识
    - 为此，需要提出挑战，留下练习题 和 拓宽思路的问题, 尽一切可能让大脑活动起来
 4. 引起读者的注意，并且要让他一直保持注意
    - 你的大脑注意的是那些不一般，有些奇怪，抢眼的，意料之外的东西
    - 如果学习过程不乏味，你的大脑很快就会学会
 5. 影像读者的情绪
    - 记忆能力很大程度上取决于所记的内容对我们情绪有怎样的影响
    - 惊讶，好奇，觉得有趣
    - 自豪感 -- 解决了一个难题

--- 

可以用下面的方法让你的大脑就范

 1. 慢一点， 你理解的越多，需要记的就越少
    - 大脑想的越深，就越有可能学会并记住
 2. 勤做练习，自己记笔记
    - 学习过程中如果能实际动动手，将改善你的学习效果
 3. 上床睡觉之前不要再看别的书了，或者至少不要再看其他有难度的数
    - 学习中有一部分是在你合上书之后完成的，你的大脑需要时间来在做一些处理
    - 如果在这个时间段你又往大脑里灌输了新的知识，那么你刚学会的一些东西就会被丢掉
 4. 大声说出来
    - 大声解释给别人听
 5. 听听你的大脑怎么说
    - 发现自己开始浮光掠影地翻看，或者刚看的东西就忘记了，这说明你该休息一会儿了
 6. 要有点感觉
    - 你的大脑需要知道这是很重要的东西
 7. 设计一些东西
    - 将学来的东西应用到新项目中，甚至重构旧项目


<h2 id="5616caa0254d9d34b75045c12685203e"></h2>


# 1 设计模式入门

- 使用模式最好的方式是： 
    - 把模式装进脑子里， 然后在你的设计和已有的应用中，寻找何处可以使用它们。
    - 以往是代码复用，现在是 经验复用
 



<h2 id="7f10b11f53861282996d481d333af15f"></h2>


# 策略模式

- 鸭子模型
- 设计原则
    - 找出应用中可能需要变化之处，把它们独立出去，不要和那些不需要变化的代码混在一起
        - 把会变化的部分取出，并“封装”起来，好让其他部分不会受到影响
        - 代码变化引起的不经意后果变少，系统变得更有弹性
    - 针对接口编程，而不是针对实现编程
        - 具体的实现由其他类负责
            - 如果某个行为具体的实现对应类B， 那么我们只要维护 类B实例的接口引用即可
                - idea of delegate
        - 说明：针对接口编程 真正的意思是“针对超类型” 编程
            - 这里的接口有多种含义，它是一个概念，也是一个Java的Interface 构造
            - 可以在不涉及java interface的情况下，“针对结构编程”， 关键在多态。
                - java 通过 继承／重写 也可以实现多态
        - **实现一个接口，并不一定表示 “写一个类，并利用 implement关键子来实现某个java接口”， 实现一个接口，反之 实现某个超类型（可以是类或接口)**
    - 多用组合，少用继承
        - 使用组合建立系统具有很大的弹性，不仅可将算法封装成类，更可以 在运行时动态改变行为
        - "有一个"，可能比 "是一个" 更好
- Strategy Pattern
    - 策略模式 定义算法族（可以理解 为多组具体的实现？），分别封装起来，让它们之间可以互相替换，此模式让算法的变化 独立于使用算法的客户。


<h2 id="ed69b1ebfd1c60c731c99be83683c89a"></h2>


# 观察者模式

- 气象站公告板
- 设计原则
    - 为了交互对象之间的松耦合设计而努力
- 观察者模式提供了一种对象设计，让主题和观察者之间松耦合
    - interface Subject 
        - registerObserver( Observer o ) 
        - removeObserver( Observer o )
        - notifyObservers()
    - interface Observer
        - update( xxxxx, xxx ,xx  )
- java 内置的 Observer 模式 支持 推／拉数据 两种方法
    - java.util
        - Observer 接口 
        -  Observerable 类  -- kind of interface Subject
            - 但是 违反了 “针对接口编程，而不是针对实现编程” 原则
    - support push/pull data
- 观察者模式
    - 在对象之间定义1对多的一来，这样一来，当一个对象改变状态，依赖他的对象都会收到通知，并自动更新


<h2 id="815e385363f17f4a5efd3aadecc64271"></h2>


# 装饰者模式
    
- starbuzz 
    - 计算价格： 双倍摩卡加奶泡Espresso
- 设计原则
    - 类应该 对扩展开放，对修改关闭
        - 遵循开放-关闭原则，通常会引入新的抽象层次，增加代码的负责度。 你需要把注意力集中在设计中最有可能改变的地方，然后应用开放-关闭原则。
- 装饰者模式
    - 动态地 将责任附加到对象身上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案
        - 装饰者 和 被装饰的组件 有相同的类型
        - 装饰者 可以在被 被装饰者 行为前面／后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的
        - 你可以用无数装饰者 包装一个组建
        - 装饰者会 导致设计中出现许多小对象，如果过度使用，会让程序变得复杂
- 真实世界的装饰者：Java I/O
    - BufferInputStream and LineNumberInputStream are both extends from FilterInputStream 
    - FilterInputStream is an abstract decorator class
    - 缺点：装饰者模式，常常造成设计中有 大量的小类，数量实在太多。

<h2 id="b98e9d7c0cb2b3d179c16457b10e53b4"></h2>


# 工厂模式

- 至今为止，创建具体类的实例，还是使用new xxx，当要加入新的具体类时，你的代码并非 “对修改关闭”。
- orderPizza
    - 根据pizza种类，实例化不同的pizza，菜单加入新pizza，删除旧pizza都要改实例化代码
    - 有加盟店还同时想改良 配方
- 工厂方法模式
    - 定义了一个创建对象的接口，但由子类 决定要实例化的是哪一类。 工厂方法把实例化推迟到子类
    - 工厂方法用来处理对象的创建， 并将这样的行为封装在 子类中。这样，客户程序中 关于超类的代码就和 子类对象创建代码解耦了
- 利用静态方法定义一个简单的工厂
    - 很常见的技巧，称为静态工厂
    - 缺点：不能通过继承来改变创建方法的行为
- 设计原则： 依赖倒置原则
    - 要依赖抽象，不要依赖具体类
        - 这个原则说明了，不能让 高层组件依赖 底层组件，而且 各层组件都应该依赖于抽象 
        - eg. PizzaStore 是 高层组件，Pizza是 低层组件
    - tips help you to follow Dependency Inversion Principle     
        1. 变量不可以持有具体类的引用
            - 使用new 就会持有具体类的引用，改用工厂来避开这样的做法
        2. 不要 让类派生自 具体类
            - 派生自具体类，你就会依赖具体类，请派生自一个抽象（接口或抽象类）
        3. 不要覆盖基类中已实现的方法
            - 如果覆盖了，那么你的基类就不是一个真正适合被继承的 抽象。
- 抽象工厂模式
    - 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类
    - 抽象工厂的每个方法 实际上都像是工厂方法。 抽象工厂的方法 经常以 工厂方法的方式实现


<h2 id="c8ef5b6fbf8c995ba753dbf56c4f4981"></h2>


# 单件模式

- 多线程下需要注意

```java
public class Singleton {
    private volatile static Singleton uniqueInstance ;
    private Singleton() {};
    public static Singleton getInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null)
                    uniqueInstance = new Singleton() ;
            }
        }   
    }    
    return uniqueInstance ;   
}
```

- volatile 解决内存可见性，确保读写到内存最新值，而不是缓存
- synchronized (Singleton.class) 保护类对象
- 可不可继承Singleton？
    - 继承会遇到一个问题： 构造器是私有的。 如果把构造器改为 public，就不是真正的单件了。

<h2 id="a5c7aeffdabd7096cc1366f19600fa62"></h2>


# 命令模式



